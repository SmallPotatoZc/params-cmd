// Generated by CoffeeScript 2.2.3
(function() {
  var Parameters, default_config,
    indexOf = [].indexOf;

  default_config = {
    name: "server",
    description: "",
    commands: [
      {
        name: "test",
        description: "test",
        options: [
          {
            name: "host",
            shortcut: "h",
            description: "host"
          }
        ]
      },
      {
        name: "test2",
        description: "test2",
        options: [
          {
            name: "host",
            shortcut: "h",
            description: "host"
          }
        ]
      }
    ]
  };

  Parameters = function() {
    return console.log('dddd');
  };

  Parameters.prototype.parse = function(argv = process) {
    var config, index, params, parse;
    if (typeof argv === 'string') {
      argv = argv.split(' ');
    }
    index = 0;
    // Remove node and script argv elements
    if (argv === process) {
      index = 2;
      argv = argv.argv;
    }
    // Extracted parameters
    params = {};
    parse = (config) => {
      var _, command, helping, i, key, leftover, len, main, option, ref, ref1, ref2, shortcut, type, value, values;
      // Read options
      while (true) {
        if (argv.length === index || argv[index][0] !== '-') {
          break;
        }
        key = argv[index++];
        shortcut = key[1] !== '-';
        key = key.substring((shortcut ? 1 : 2), key.length);
        if (shortcut) {
          shortcut = key;
        }
        if (shortcut) {
          key = config.shortcuts[shortcut];
        }
        option = (ref = config.options) != null ? ref[key] : void 0;
        if (!shortcut && config.strict && !option) {
          throw Error(`Invalid option ${JSON.stringify(key)}`);
        }
        if (shortcut && !option) {
          if (config.root) {
            throw Error(`Invalid Shortcut: "-${shortcut}"`);
          } else {
            throw Error(`Invalid Shortcut: "-${shortcut}" in command "${config.name}"`);
          }
        }
        // Auto discovery
        if (!option) {
          type = argv[index] && argv[index][0] !== '-' ? 'string' : 'boolean';
          option = {
            name: key,
            type: type
          };
        }
        switch (option.type) {
          case 'boolean':
            params[key] = true;
            break;
          case 'string':
            value = argv[index++];
            if (value == null) {
              throw Error(`Invalid Option: no value found for option ${JSON.stringify(key)}`);
            }
            if (value[0] === '-') {
              throw Error(`Invalid Option: no value found for option ${JSON.stringify(key)}`);
            }
            params[key] = value;
            break;
          case 'integer':
            value = argv[index++];
            if (value == null) {
              throw Error(`Invalid Option: no value found for option ${JSON.stringify(key)}`);
            }
            if (value[0] === '-') {
              throw Error(`Invalid Option: no value found for option ${JSON.stringify(key)}`);
            }
            params[key] = parseInt(value, 10);
            break;
          case 'array':
            value = argv[index++];
            if (value == null) {
              throw Error(`Invalid Option: no value found for option ${JSON.stringify(key)}`);
            }
            if (value[0] === '-') {
              throw Error(`Invalid Option: no value found for option ${JSON.stringify(key)}`);
            }
            if (params[key] == null) {
              params[key] = [];
            }
            params[key].push(...value.split(','));
        }
      }
      // Check if help is requested
      helping = false;
      ref1 = config.options;
      for (_ in ref1) {
        option = ref1[_];
        if (option.help !== true) {
          continue;
        }
        if (params[option.name]) {
          helping = true;
        }
      }
      if (helping) {
        return params;
      }
      ref2 = config.options;
      // Check against required options
      for (_ in ref2) {
        option = ref2[_];
        if (option.required) {
          if (!(helping || (params[option.name] != null))) {
            throw Error(`Required option argument "${option.name}"`);
          }
        }
        if (option.one_of) {
          values = params[option.name];
          if (!Array.isArray(values)) {
            values = [values];
          }
          for (i = 0, len = values.length; i < len; i++) {
            value = values[i];
            if (indexOf.call(option.one_of, value) < 0) {
              throw Error(`Invalid value "${value}" for option "${option.name}"`);
            }
          }
        }
      }
      // We still have some argument to parse
      if (argv.length !== index) {
        // Store the full command in the return object
        leftover = argv.slice(index).join(' ');
        if (config.main) {
          params[config.main.name] = leftover;
        } else {
          command = argv[index];
          if (!config.commands[command]) {
            // Validate the command
            throw Error(`Fail to parse end of command "${leftover}"`);
          }
          // Set the parameter relative to the command
          if (typeof params[config.command] === 'string') {
            params[config.command] = [params[config.command]];
          }
          if (Array.isArray(params[config.command])) {
            params[config.command].push(argv[index++]);
          } else {
            params[config.command] = argv[index++];
          }
          // Parse child configuration
          parse(config.commands[command], argv);
        }
      }
      // Command mode but no command are found, default to help
      // Happens with global options without a command
      if (Object.keys(this.config.commands).length && !params[this.config.command]) {
        params[this.config.command] = 'help';
      }
      // Check against required main
      main = config.main;
      if (main) {
        if (main.required) {
          if (params[main.name] == null) {
            throw Error(`Required main argument "${main.name}"`);
          }
        }
      }
      return params;
    };
    // If they are commands (other than help) and no arguments are provided,
    // we default to the help action
    if (Object.keys(this.config.commands).length && argv.length === index) {
      argv.push('help');
    }
    // If there are commands... for the rest, i dont know, might be old leftover
    if (Object.keys(this.config.commands).length && argv[index].substr(0, 1) !== '-') {
      config = this.config.commands[argv[index]];
      if (!config) {
        throw Error(`Invalid Command: "${argv[index]}"`);
      }
      params[this.config.command] = argv[index++];
    } else {
      config = this.config;
    }
    // Start the parser
    params = parse(config, argv);
    // Enrich params with default values
    set_default(this.config, params);
    return params;
  };

}).call(this);
